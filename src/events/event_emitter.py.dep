import asyncio
from collections import defaultdict
from typing import Callable, Dict, Optional
from src.utils import get_event_loop

class EventEmitter:
    def __init__(self, external: Optional["EventEmitter"] = None):
        self._external = external
        self._listeners: Dict[str, list[Callable]] = defaultdict(list) if external is None else None

    def on(self, event: str, callback: Callable):
        if self._external:
            return self._external.on(event, callback)
        if callback not in self._listeners[event]:
            self._listeners[event].append(callback)

    def off(self, event: str, callback: Callable):
        if self._external:
            return self._external.off(event, callback)
        if event in self._listeners:
            self._listeners[event] = [cb for cb in self._listeners[event] if cb != callback]

    def once(self, event: str, callback: Callable):
        if self._external:
            return self._external.once(event, callback)

        def internal_callback(*args, **kwargs):
            self.off(event, internal_callback)
            loop = get_event_loop()
            loop.call_soon(callback, *args, **kwargs)

        self.on(event, internal_callback)

    def emit(self, event: str, *args, **kwargs):
        if self._external:
            return self._external.emit(event, *args, **kwargs)
        if event in self._listeners:
            loop = get_event_loop()
            for listener in list(self._listeners[event]):
                loop.call_soon(listener, *args, **kwargs)

